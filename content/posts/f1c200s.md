---
title: "F1c200s基础开发"
date: 2026-03-02T21:10:09+08:00
draft: false
tags: ["Linux", "F1C200S", "embedded"]
categories: ["技术文档"]
summary: "F1C200S的开发环境搭建 基础linux内核 u-boot 根文件系统构建"
---

# 一 环境准备
## 下载编译工具
编译工具链网站 <https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/arm-linux-gnueabi/>
由于用的是xubuntu系统 不想消耗编译速度 于是没有使用
## 手动管理交叉编译环境
1. 终端输入如下命令
```
mkdir -p ~/toolchains
# 以 arm-none-linux-gnueab 为例（根据你的 F1C200S 内核要求选择）
tar -xvf arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-linux-gnueab.tar.xz -C ~/toolchains/

```
这样可以避免污染usr/bin
2. 项目根目录下新建env.sh 输入以下内容
```
export ARCH=arm
export CROSS_COMPILE=arm-linux-gnueabi-
export PATH=$PATH:/home/adrian/F1C200S/tools/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabi/bin:$PATH
echo "F1C200S Build Environment Loaded!"
echo "ARCH: $ARCH"
echo "Cross Compiler: $(which ${CROSS_COMPILE}gcc)"
echo "GCC Version:"
arm-linux-gnueabi-gcc -v | grep "gcc version"
```
终端输入
```
source env.sh
```
如果显示
```
xxxxx
gcc-version 7.5
```
则说明环境搭建成功了
## U-boot的配置与编译
1. 安装U-boot编译依赖
```
sudo apt install libssl-dev device-tree-compiler swig python3-dev python3-setuptools

```
2. 获取U-boot源码
```
git clone https://github.com/u-boot/u-boot.git
```
然后cd到下载源码的文件夹
3. 配置U-boot
确保已经加载了环境 source env.sh 
```
# 这条命令会生成 .config 文件，告诉编译器我们要针对 F1C200S 编译
make licheepi_nano_defconfig ##加载配置

```
4. 编译
在U-boot文件夹里运行
```
# -j 后面的数字取决于你电脑 CPU 的核心数，写大点编译快
make -j8
```
然后执行 
``` 
ls -lh u-boot-sunxi-with-spl.bin
```
如果文件存在且大小约为400--600kb,说明编译成功了
## linux内核编译
1. 下载内核源码
执行命令
```
cd ~/F1C200S

# 克隆 Lichee Pi 官方维护的 Linux 内核分支
git clone --depth=1 -b nano-5.2-tf https://github.com/Lichee-Pi/linux.git

# 进入内核目录
cd linux

```
注意路径
2. 配置编译环境
用GCC7.5版本
```
# 1. 再次确认环境变量（如果你关闭过终端，请必须重新执行下面两行）
export PATH=~/F1C200S/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabi/bin:$PATH
export CROSS_COMPILE=arm-linux-gnueabi-
export ARCH=arm

# 2. 验证编译器版本（确保显示的是 7.5.0 而不是系统自带的）
${CROSS_COMPILE}gcc --version
```
3. 加载配置
在项目中的/linux文件夹里打开终端，执行
```
make licheepi_nano_defconfig
```
4. 编译
在编译前查看一下设备树
```
ls arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts
```
如果有这个文件，执行编译
```
# -j 后面的数字建议设为你 CPU 核心数的 2 倍，例如 -j4 或 -j8
make -j$(nproc) zImage dtbs
```
完成后输入
```
ls -lh arch/arm/boot/zImage arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb

```
注意路径，如果显示
```
-rw-rw-r-- 1 adrian adrian 5.8K  2月 14 15:42 arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb
-rwxrwxr-x 1 adrian adrian 3.0M  2月 14 15:48 arch/arm/boot/zImage

```
则说明内核编译成功了
## 构建文件系统
1. 获取busybox
```
cd ~/F1C200S
wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2
tar -jxvf busybox-1.36.1.tar.bz2
cd busybox-1.36.1
```
2. 设置编译环境
这里跟内核设置流程一样
3. 完全参考<https://www.cnblogs.com/twzy/p/15355842.html>的教程 
## 填坑
U-boot编译时，发现gcc版本太老了。于是执行一下命令
```
# 1. 进入工具目录
cd ~/F1C200S/tools

# 2. 下载 ARM 官方 GCC 10.3 工具链 (约 130MB)
wget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabi.tar.xz

# 3. 解压
tar -xvf gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabi.tar.xz

# 4. 删除压缩包（可选，节省空间）
rm gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabi.tar.xz

```
目录填自己的，重新下载一个gcc编译器
然后修改env.sh
```
#!/bin/bash

# 1. 获取当前脚本所在的绝对路径 (比使用 $PWD 更稳健)
export PROJ_ROOT="/home/adrian/F1C200S"

# 2. 设置工具链的路径
# 注意：这里必须是你刚才下载并解压出来的那个 GCC 10.3 的文件夹名
TOOLCHAIN_PATH="$PROJ_ROOT/tools/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabi/bin"

# 3. 将工具链加入 PATH
export PATH="$TOOLCHAIN_PATH:$PATH"

# 4. 设置交叉编译前缀
# 关键点！ARM官方工具链通常包含 'none'，请根据第一步ls看到的结果填写
export CROSS_COMPILE=arm-none-linux-gnueabi-

# 5. 设置架构
export ARCH=arm

# --- 下面是打印调试信息，帮助我们确认是否设置成功 ---
echo "F1C200S Build Environment Loaded!"
echo "ARCH: $ARCH"
echo "CROSS_COMPILE: $CROSS_COMPILE"

# 尝试检查 gcc 版本，验证路径是否正确
# 这里的 ${CROSS_COMPILE}gcc 会被展开为 arm-none-linux-gnueabi-gcc
COMPILER_VERSION=$(${CROSS_COMPILE}gcc --version 2>/dev/null | head -n 1)

if [ -n "$COMPILER_VERSION" ]; then
    echo "Compiler Found: $COMPILER_VERSION"
else
    echo "ERROR: Compiler NOT found!"
    echo "Looking in: $TOOLCHAIN_PATH"
    echo "Trying to execute: ${CROSS_COMPILE}gcc"
fi

```
注意路径 然后重新加载后就可以了
```
cd u-boot
make distclean
make licheepi_nano_defconfig
make -j4
```
编译linux内核时，出现如下问题：
> /usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x20): multiple definition of `yylloc'; scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first defined here
   collect2: error: ld returned 1 exit status
  make[1]: *** [scripts/Makefile.host:99：scripts/dtc/dtc] 错误 1
  make: *** [Makefile:1265：scripts_dtc] 错误 2

原因是ubuntu自带的GCC版本太高 默认不支持.o文件里的重复定义。
解决方法：在项目的/linux文件夹里执行
```
# 使用 sed 命令修改 dtc-lexer.l 文件，给 yylloc 加上 extern 关键字
sed -i 's/^YYLTYPE yylloc;$/extern YYLTYPE yylloc;/' scripts/dtc/dtc-lexer.l
```
再执行
```
make -j$(nproc) zImage dtbs
```
